---
output: github_document
---
<!-- .md is generated from .Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r, message = FALSE, include=FALSE}
library(dplyr)
library(sastats)
```

# Overview

Outliers should be considered with continuous survey variables. There are no hard and fast rules for outlier identification, but [Tukey's Test]( https://en.wikipedia.org/wiki/Outlier#Tukey%27s_fences) provides one method that is easy to apply in a standard way.

For demonstration, package sastats includes a survey dataset with annual participation days for several outdoor recreation activities:

```{r}
library(dplyr)
library(sastats)

data(svy) # list with 2 data frames: person, act
activities <- svy$act

glimpse(activities)
```

## Visualize

Visualizing the data is a first step for examining outliers. We can use `sastats::outlier_plot()` which is largely a wrapper for `ggplot2::geom_boxplot()`. 

After running this function, we can see that the distributions are highly skewed and difficult to view. Additionally, the position of the whiskers suggests that we would be flagging many reasonable values as outliers (e.g., those above 20 or so for fishing).

```{r}
outlier_plot(activities, days, act, ignore_zero = TRUE)
```

An argument is included to allow us to log transform the y-axis. This makes for more normal distributions, and likely provides a more reasonable criteria for outlier identification.

```{r}
outlier_plot(activities, days, act, apply_log = TRUE)
```

## Flag Outliers

We can use `outlier_tukey()` to flag those values observed to be outliers:

```{r}
activities <- activities %>%
    group_by(act) %>% 
    mutate(
        is_outlier = outlier_tukey(days, apply_log = TRUE), 
        days_cleaned = ifelse(is_outlier, NA, days) 
    ) %>% 
    ungroup()

outlier_plot(activities, days, act, apply_log = TRUE, show_outliers = TRUE)
```

We have a couple more summary functions available to show the effects of outlier removal:

```{r}
outlier_pct(activities, act)

outlier_mean_compare(activities, days, days_cleaned, act) 
```

### Topcode

Instead of removing outliers, we could use `outlier_tukey_top()` to topcode:

```{r}
activities <- activities %>%
    group_by(act) %>%
    mutate(
        topcode_value = outlier_tukey_top(days, apply_log = TRUE),
        days_cleaned = ifelse(is_outlier, topcode_value, days)
    ) %>%
    ungroup()

outlier_pct(activities, act)

outlier_mean_compare(activities, days, days_cleaned, act)
```

