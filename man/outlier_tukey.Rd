% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/outliers.R
\name{outlier_tukey}
\alias{outlier_tukey}
\alias{outlier_tukey_top}
\title{Flag outliers based on tukey's rule}
\usage{
outlier_tukey(
  x,
  k = 1.5,
  ignore_lwr = FALSE,
  apply_log = FALSE,
  ignore_zero = FALSE
)

outlier_tukey_top(x, k = 1.5, apply_log = FALSE, ignore_zero = FALSE)
}
\arguments{
\item{x}{input values to check}

\item{k}{the iqr multiplier that determines the fence level. Increasing will
make outlier identification less strict (& vice-versa)}

\item{ignore_lwr}{If TRUE, don't use the lower fence for identifying outliers}

\item{apply_log}{If TRUE, log transform input values prior to applying tukey's
rule. Useful since distributions often have a log-normal shape (e.g., spending)}

\item{ignore_zero}{If TRUE, will exclude zero values from IQR & flagging.
Note that zeroes will automatically be ignored if apply_log = TRUE}
}
\description{
Returns a logical vector where TRUE indicates outliers.
}
\section{Functions}{
\itemize{
\item \code{outlier_tukey_top}: get the largest non-outlier value for top-coding
}}

\examples{
library(dplyr)
data(svy)

# take a look at the days variable
outlier_plot(svy$act, days, act)
outlier_plot(svy$act, days, act, apply_log = TRUE)

activity <- group_by(svy$act, act) \%>\% mutate(
    is_outlier = outlier_tukey(days, ignore_zero = TRUE, apply_log = TRUE),
    # in case we want to topcode the outliers:
    topcode_value = outlier_tukey_top(days, apply_log = TRUE),
    days_cleaned = ifelse(is_outlier, NA, days)
) \%>\% ungroup()

# summarize
outlier_plot(activity, days, act, apply_log = TRUE, show_outliers = TRUE)
outlier_pct(activity, act)
outlier_mean_compare(activity, days, days_cleaned, act)
}
\seealso{
Other functions for identifying outliers: 
\code{\link{outlier_mean_compare}()},
\code{\link{outlier_pct}()},
\code{\link{outlier_plot}()}
}
\concept{functions for identifying outliers}
